// Script d'analyse des doublons de r√©servations
require('dotenv').config();
const mongoose = require('mongoose');
const Booking = require('../models/Booking');
const Mission = require('../models/Mission');
const Apartment = require('../models/Apartment');

async function analyzeDuplicateBookings() {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });

    console.log('üîç Analyse des doublons de r√©servations...\n');

    // R√©cup√©rer tous les appartements actifs
    const apartments = await Apartment.find({ isActive: true }).lean();
    
    for (const apartment of apartments) {
      console.log(`üìç Appartement: ${apartment.name} (${apartment._id})`);
      
      // R√©cup√©rer toutes les r√©servations pour cet appartement
      const bookings = await Booking.find({
        apartment: apartment._id,
        status: 'Confirm√©'
      }).sort({ dateDebut: 1 }).lean();

      if (bookings.length === 0) {
        console.log('  ‚Ü≥ Aucune r√©servation\n');
        continue;
      }

      // Grouper par jour (UTC, ignore les heures)
      const bookingsByDay = new Map();
      
      for (const booking of bookings) {
        const dayKey = booking.dateDebut.toISOString().split('T')[0]; // YYYY-MM-DD
        
        if (!bookingsByDay.has(dayKey)) {
          bookingsByDay.set(dayKey, []);
        }
        bookingsByDay.get(dayKey).push(booking);
      }

      // Analyser les doublons
      let duplicatesFound = false;
      for (const [day, dayBookings] of bookingsByDay) {
        if (dayBookings.length > 1) {
          duplicatesFound = true;
          console.log(`  ‚ö†Ô∏è  ${day}: ${dayBookings.length} r√©servations`);
          
          for (const booking of dayBookings) {
            console.log(`    - ${booking.externalId} (${booking.source}): ${booking.dateDebut.toISOString()} ‚Üí ${booking.dateFin.toISOString()}`);
          }
        }
      }

      if (!duplicatesFound) {
        console.log('  ‚úÖ Aucun doublon d√©tect√©');
      }

      // V√©rifier les missions automatiques pour cet appartement
      const autoMissions = await Mission.find({
        apartment: apartment._id,
        'metadata.autoGenerated': true
      }).sort({ dateDebut: 1 }).lean();

      if (autoMissions.length > 0) {
        console.log(`  üîß ${autoMissions.length} missions automatiques trouv√©es`);
        
        // Grouper les missions par jour
        const missionsByDay = new Map();
        for (const mission of autoMissions) {
          const dayKey = mission.dateDebut.toISOString().split('T')[0];
          if (!missionsByDay.has(dayKey)) {
            missionsByDay.set(dayKey, []);
          }
          missionsByDay.get(dayKey).push(mission);
        }

        // D√©tecter les doublons de missions
        for (const [day, dayMissions] of missionsByDay) {
          if (dayMissions.length > 1) {
            console.log(`  üö® ${day}: ${dayMissions.length} missions automatiques (DOUBLON!)`);
            for (const mission of dayMissions) {
              console.log(`    - Mission ${mission._id}: ${mission.title} (${mission.dateDebut.toISOString()})`);
            }
          }
        }
      }

      console.log(''); // Ligne vide pour s√©parer les appartements
    }

    console.log('‚úÖ Analyse termin√©e');
    await mongoose.disconnect();
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'analyse:', error);
    process.exit(1);
  }
}

// Fonction pour nettoyer les missions en double (optionnel)
async function cleanDuplicateMissions() {
  try {
    console.log('üßπ Nettoyage des missions en double...\n');

    const apartments = await Apartment.find({ isActive: true }).lean();
    let totalCleaned = 0;

    for (const apartment of apartments) {
      console.log(`üìç Nettoyage pour: ${apartment.name}`);

      // R√©cup√©rer toutes les missions auto pour cet appartement
      const autoMissions = await Mission.find({
        apartment: apartment._id,
        'metadata.autoGenerated': true
      }).sort({ dateDebut: 1 });

      // Grouper par jour
      const missionsByDay = new Map();
      for (const mission of autoMissions) {
        const dayKey = mission.dateDebut.toISOString().split('T')[0];
        if (!missionsByDay.has(dayKey)) {
          missionsByDay.set(dayKey, []);
        }
        missionsByDay.get(dayKey).push(mission);
      }

      // Pour chaque jour avec des doublons, garder seulement la premi√®re mission
      for (const [day, dayMissions] of missionsByDay) {
        if (dayMissions.length > 1) {
          console.log(`  üóëÔ∏è  ${day}: suppression de ${dayMissions.length - 1} mission(s) en double`);
          
          // Garder la premi√®re mission (la plus ancienne)
          const toKeep = dayMissions[0];
          const toDelete = dayMissions.slice(1);

          for (const mission of toDelete) {
            await Mission.findByIdAndDelete(mission._id);
            totalCleaned++;
            console.log(`    ‚úó Supprim√©e: ${mission._id}`);
          }
          console.log(`    ‚úì Conserv√©e: ${toKeep._id}`);
        }
      }
    }

    console.log(`\n‚úÖ Nettoyage termin√©: ${totalCleaned} missions supprim√©es`);
  } catch (error) {
    console.error('‚ùå Erreur lors du nettoyage:', error);
  }
}

// Ex√©cution
if (require.main === module) {
  const args = process.argv.slice(2);
  
  if (args.includes('--clean')) {
    // Mode nettoyage
    (async () => {
      await mongoose.connect(process.env.MONGODB_URI, {
        useNewUrlParser: true,
        useUnifiedTopology: true,
      });
      await cleanDuplicateMissions();
      await mongoose.disconnect();
      process.exit(0);
    })();
  } else {
    // Mode analyse par d√©faut
    analyzeDuplicateBookings();
  }
}

module.exports = { analyzeDuplicateBookings, cleanDuplicateMissions };