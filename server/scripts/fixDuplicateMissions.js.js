// Enhanced script to fix duplicate missions and validate system integrity
require('dotenv').config();
const mongoose = require('mongoose');
const Mission = require('../models/Mission');
const Apartment = require('../models/Apartment');
const { runDiagnostics } = require('../services/missionAutomationService');

async function fixDuplicateMissions() {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });

    console.log('üîß Starting duplicate mission cleanup...\n');

    // Run diagnostics first
    console.log('üìä Running pre-cleanup diagnostics...');
    const preDiagnostics = await runDiagnostics();
    console.log('Pre-cleanup duplicates:', preDiagnostics.duplicateAnalysis);

    // Find duplicate automatic missions
    const duplicateGroups = await Mission.aggregate([
      {
        $match: {
          'metadata.autoGenerated': true
        }
      },
      {
        $group: {
          _id: {
            apartment: '$apartment',
            day: {
              $dateToString: {
                format: '%Y-%m-%d',
                date: '$dateDebut'
              }
            }
          },
          count: { $sum: 1 },
          missions: { 
            $push: {
              id: '$_id',
              dateDebut: '$dateDebut',
              createdAt: '$createdAt',
              status: '$status',
              operationId: '$metadata.operationId'
            }
          }
        }
      },
      {
        $match: {
          count: { $gt: 1 }
        }
      }
    ]);

    console.log(`\nüîç Found ${duplicateGroups.length} groups with duplicate missions`);

    if (duplicateGroups.length === 0) {
      console.log('‚úÖ No duplicates found, system is clean');
      await mongoose.disconnect();
      return;
    }

    let totalCleaned = 0;
    let totalKept = 0;

    for (const group of duplicateGroups) {
      const { apartment, day } = group._id;
      const missions = group.missions;
      
      console.log(`\nüìç Processing apartment ${apartment} on ${day}:`);
      console.log(`  Found ${missions.length} duplicate missions`);

      // Sort missions: prefer newer createdAt, then by status priority
      const statusPriority = { 'En cours': 1, 'En attente': 2, 'Termin√©': 3, 'Probl√®me': 4, 'Annul√©': 5 };
      
      missions.sort((a, b) => {
        // First by status priority
        const statusDiff = (statusPriority[a.status] || 99) - (statusPriority[b.status] || 99);
        if (statusDiff !== 0) return statusDiff;
        
        // Then by creation date (newer first)
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
      });

      // Keep the first mission (best priority + newest)
      const toKeep = missions[0];
      const toDelete = missions.slice(1);

      console.log(`  ‚úì Keeping mission ${toKeep.id} (status: ${toKeep.status}, created: ${toKeep.createdAt})`);
      totalKept++;

      // Delete the rest
      for (const mission of toDelete) {
        try {
          await Mission.findByIdAndDelete(mission.id);
          console.log(`  ‚úó Deleted mission ${mission.id} (status: ${mission.status}, created: ${mission.createdAt})`);
          totalCleaned++;
        } catch (deleteError) {
          console.error(`  ‚ùå Failed to delete mission ${mission.id}:`, deleteError.message);
        }
      }
    }

    console.log(`\nüìà Cleanup Summary:`);
    console.log(`  - Duplicate groups processed: ${duplicateGroups.length}`);
    console.log(`  - Missions kept: ${totalKept}`);
    console.log(`  - Missions deleted: ${totalCleaned}`);

    // Run post-cleanup diagnostics
    console.log('\nüìä Running post-cleanup diagnostics...');
    const postDiagnostics = await runDiagnostics();
    console.log('Post-cleanup duplicates:', postDiagnostics.duplicateAnalysis);

    // Verify cleanup was successful
    if (postDiagnostics.duplicateAnalysis.duplicateGroups === 0) {
      console.log('‚úÖ Cleanup successful - no duplicates remaining');
    } else {
      console.log('‚ö†Ô∏è Some duplicates may remain, manual review recommended');
    }

    await mongoose.disconnect();
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Error during duplicate cleanup:', error);
    process.exit(1);
  }
}

// Function to validate mission date consistency
async function validateMissionDateConsistency() {
  try {
    console.log('üîç Validating mission date consistency...\n');

    const missions = await Mission.find({
      'metadata.autoGenerated': true
    }).populate('apartment', 'name').lean();

    const issues = [];

    for (const mission of missions) {
      const missionDate = new Date(mission.dateDebut);
      const now = new Date();
      const daysDifference = Math.ceil((missionDate.getTime() - now.getTime()) / (24 * 60 * 60 * 1000));

      // Check if mission is scheduled with proper advance notice
      if (daysDifference < 30 && mission.status !== 'Termin√©' && mission.status !== 'Annul√©') {
        issues.push({
          missionId: mission._id,
          apartmentName: mission.apartment?.name || 'Unknown',
          missionDate: missionDate.toISOString().split('T')[0],
          daysDifference,
          status: mission.status,
          issue: 'Insufficient advance notice'
        });
      }

      // Check for weekend missions (optional validation)
      const dayOfWeek = missionDate.getDay();
      if (dayOfWeek === 0 || dayOfWeek === 6) { // Sunday or Saturday
        console.log(`  ‚ÑπÔ∏è Weekend mission detected: ${mission._id} on ${missionDate.toISOString().split('T')[0]} (${mission.apartment?.name})`);
      }
    }

    if (issues.length > 0) {
      console.log(`‚ö†Ô∏è Found ${issues.length} missions with date issues:`);
      issues.forEach(issue => {
        console.log(`  - ${issue.missionId}: ${issue.apartmentName} on ${issue.missionDate} (${issue.daysDifference} days, ${issue.issue})`);
      });
    } else {
      console.log('‚úÖ All mission dates are consistent');
    }

    return issues;
  } catch (error) {
    console.error('‚ùå Error validating mission dates:', error);
    throw error;
  }
}

// Main execution
if (require.main === module) {
  const args = process.argv.slice(2);
  
  if (args.includes('--validate-dates')) {
    (async () => {
      await mongoose.connect(process.env.MONGODB_URI, {
        useNewUrlParser: true,
        useUnifiedTopology: true,
      });
      await validateMissionDateConsistency();
      await mongoose.disconnect();
      process.exit(0);
    })();
  } else {
    fixDuplicateMissions();
  }
}

module.exports = { fixDuplicateMissions, validateMissionDateConsistency };