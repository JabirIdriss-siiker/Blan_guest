const mongoose = require('mongoose');
const Mission   = require('../models/Mission');
const Booking   = require('../models/Booking');
const User      = require('../models/User');
const Apartment = require('../models/Apartment');
const { sendMissionNotification } = require('./emailService');

// Mod√®le de mission par d√©faut
const getDefaultMissionTemplate = (apartment, booking) => ({
  title:       `Nettoyage apr√®s d√©part - ${apartment.name}`,
  description: `Nettoyage automatique post-d√©part de ${booking.guestName || 'client'} (${booking.source})`,
  priority:    'Normale',
  cleaningPrice: apartment.cleaningPrice || 0,
  checklist: [
    'Nettoyer et d√©sinfecter toutes les surfaces',
    'Changer les draps et serviettes',
    'Nettoyer la salle de bain compl√®tement',
    'Nettoyer la cuisine et v√©rifier les √©quipements',
    'Passer l\'aspirateur et nettoyer les sols',
    'V√©rifier et nettoyer les fen√™tres',
    'Vider toutes les poubelles',
    'V√©rifier l\'√©tat g√©n√©ral de l\'appartement',
    'Prendre des photos apr√®s nettoyage'
  ].map(task => ({ task })),
  instructions: apartment.instructions || 'Suivre la proc√©dure standard.',
  estimatedDuration: 120
});

// Cache pour optimiser les requ√™tes r√©p√©t√©es
let staffCache = null;
let adminCache = null;
let cacheExpiry = 0;

// Trouve le staff le moins charg√© pour une date donn√©e (optimis√©)
async function getAvailableStaff(missionDate) {
  const now = Date.now();
  
  // Utilise le cache pendant 5 minutes
  if (!staffCache || now > cacheExpiry) {
    staffCache = await User.find({ role: 'Staff de m√©nage', isActive: true }).lean();
    adminCache = await User.findOne({ role: 'Admin' }).sort({ createdAt: 1 }).lean();
    cacheExpiry = now + 5 * 60 * 1000; // 5 minutes
  }
  
  if (staffCache.length === 0) throw new Error('Aucun staff disponible');
  
  // Comptage des missions par staff sur la journ√©e
  const dayStart = new Date(missionDate);
  dayStart.setHours(0,0,0,0);
  const dayEnd = new Date(dayStart);
  dayEnd.setDate(dayEnd.getDate()+1);

  // Batch query pour tous les staff members
  const staffIds = staffCache.map(u => u._id);
  const missionCounts = await Mission.aggregate([
    {
      $match: {
        assignedTo: { $in: staffIds },
        dateDebut: { $gte: dayStart, $lt: dayEnd }
      }
    },
    {
      $group: {
        _id: '$assignedTo',
        count: { $sum: 1 }
      }
    }
  ]);

  // Cr√©er un map pour les counts
  const countMap = new Map();
  missionCounts.forEach(item => {
    countMap.set(item._id.toString(), item.count);
  });

  // Trouver le staff avec le moins de missions
  let minCount = Infinity;
  let selectedStaff = staffCache[0];
  
  for (const staff of staffCache) {
    const count = countMap.get(staff._id.toString()) || 0;
    if (count < minCount) {
      minCount = count;
      selectedStaff = staff;
    }
  }
  
  return selectedStaff;
}

// Cr√©e une mission unique (idempotent, optimis√©)
async function createAutomaticMission(booking, apartment) {
  console.log(`üî® Cr√©ation mission auto pour booking ${booking._id}`);

  // D√©termine date/heures de la mission
  const checkout = new Date(booking.dateFin);
  const missionStart = new Date(checkout);
  if (checkout.getHours() < 12) {
    missionStart.setHours(14,0,0,0);
  } else {
    missionStart.setDate(missionStart.getDate()+1);
    missionStart.setHours(10,0,0,0);
  }
  const missionEnd = new Date(missionStart);
  missionEnd.setHours(missionStart.getHours()+3);

  // R√©cup√®re le staff et l'admin (utilise le cache)
  const [staff, admin] = await Promise.all([
    getAvailableStaff(missionStart),
    adminCache || User.findOne({ role: 'Admin' }).sort({ createdAt:1 }).lean()
  ]);
  
  if (!admin) throw new Error('Aucun administrateur trouv√©');

  // Assemble la mission
  const template = getDefaultMissionTemplate(apartment, booking);
  const mission = new Mission({
    ...template,
    apartment:   apartment._id,
    assignedTo:  staff._id,
    createdBy:   admin._id,
    dateDebut:   missionStart,
    dateFin:     missionEnd,
    metadata: {
      autoGenerated: true,
      bookingId:     booking._id,
      bookingSource: booking.source,
      guestName:     booking.guestName
    }
  });
  await mission.save();

  // Notifications (asynchrone pour ne pas bloquer)
  setImmediate(async () => {
    try {
      await mission.populate('assignedTo', 'email firstName lastName');
      await mission.populate('apartment', 'name address');
      await sendMissionNotification(mission);
      console.log(`‚úâÔ∏è Notification envoy√©e √† ${staff.email}`);
    } catch (err) {
      console.error('‚ö†Ô∏è Erreur notification:', err);
    }
  });

  console.log(`‚úÖ Mission cr√©√©e [${mission._id}]`);
  return mission;
}

// Fonction g√©n√©rique de traitement de bookings (optimis√©e)
async function processBookings(filter, label) {
  console.log(`üîç Traitement des bookings (${label})‚Ä¶`);
  
  // 1. R√©cup√®re tous les bookings correspondants
  const bookings = await Booking.find(filter).lean();
  console.log(`  ‚Üí ${bookings.length} bookings r√©cup√©r√©s`);
  
  if (bookings.length === 0) return [];

  // 2. Batch query pour r√©cup√©rer les apartments
  const apartmentIds = [...new Set(bookings.map(b => b.apartment))];
  const apartments = await Apartment.find({ 
    _id: { $in: apartmentIds }, 
    isActive: true 
  }).lean();
  
  // Cr√©er un map pour les apartments
  const apartmentMap = new Map();
  apartments.forEach(apt => {
    apartmentMap.set(apt._id.toString(), apt);
  });

  // 3. Filtrer les bookings avec apartments valides
  const validBookings = bookings.filter(b => 
    apartmentMap.has(b.apartment.toString())
  );
  console.log(`  ‚Üí ${validBookings.length} bookings avec apartments actifs`);

  if (validBookings.length === 0) return [];

  // 4. Batch query pour v√©rifier les missions existantes
  const bookingIds = validBookings.map(b => b._id);
  const existingMissionBookingIds = await Mission.find({
    'metadata.bookingId': { $in: bookingIds },
    'metadata.autoGenerated': true
  }).distinct('metadata.bookingId');

  // Convertir en Set pour recherche O(1)
  const existingSet = new Set(existingMissionBookingIds.map(id => id.toString()));

  // 5. Filtrer les nouveaux bookings
  const newBookings = validBookings.filter(b => 
    !existingSet.has(b._id.toString())
  );
  console.log(`  ‚Üí ${newBookings.length} nouvelles missions √† cr√©er`);

  if (newBookings.length === 0) return [];

  // 6. Traitement en parall√®le (par batch de 5 pour √©viter la surcharge)
  const results = [];
  const batchSize = 5;
  
  for (let i = 0; i < newBookings.length; i += batchSize) {
    const batch = newBookings.slice(i, i + batchSize);
    
    const batchPromises = batch.map(async (booking) => {
      try {
        const apartment = apartmentMap.get(booking.apartment.toString());
        const mission = await createAutomaticMission(booking, apartment);
        return { bookingId: booking._id, missionId: mission._id, success: true };
      } catch (err) {
        console.error(`‚úñÔ∏è Erreur booking ${booking._id}:`, err.message);
        return { bookingId: booking._id, success: false, error: err.message };
      }
    });

    const batchResults = await Promise.all(batchPromises);
    results.push(...batchResults);
  }

  return results;
}

// R√©servations finissant dans 5 jours (optimis√©)
async function processUpcomingBookings() {
  const now = new Date();
  const in60Days = new Date(now.getTime() + 60 * 24 * 60 * 60 * 1000); // 60 days ahead
  
  return processBookings(
  { 
    status: 'Confirm√©',
    dateDebut: { $lte: in60Days },
    dateFin:   { $gte: now }
  },
  '√† venir (60 jours overlap)'
);
}

// R√©servations termin√©es il y a moins de 24h (optimis√©)
async function processRecentlyEndedBookings() {
  const now = new Date();
  const yesterday = new Date(now.getTime() - 24*60*60*1000);
  
  return processBookings(
    { 
      dateFin: { $gte: yesterday, $lte: now }, 
      status: 'Confirm√©' 
    },
    'r√©centes (<24h)'
  );
}

// Fonction pour invalider le cache (utile pour les tests)
function clearCache() {
  staffCache = null;
  adminCache = null;
  cacheExpiry = 0;
}

module.exports = {
  createAutomaticMission,
  processUpcomingBookings,
  processRecentlyEndedBookings,
  getDefaultMissionTemplate,
  clearCache
};