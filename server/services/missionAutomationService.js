const mongoose = require('mongoose');
const Mission   = require('../models/Mission');
const Booking   = require('../models/Booking');
const User      = require('../models/User');
const Apartment = require('../models/Apartment');
const { sendMissionNotification } = require('./emailService');
const { createLaundryTaskForMission } = require('./laundryService');

// Mod√®le de mission par d√©faut
const getDefaultMissionTemplate = (apartment, booking) => ({
  title:       `Nettoyage apr√®s d√©part - ${apartment.name}`,
  description: `Nettoyage automatique post-d√©part de ${booking.guestName || 'client'} (${booking.source})`,
  priority:    'Normale',
  cleaningPrice: apartment.cleaningPrice || 0,
  checklist: [
    'Nettoyer et d√©sinfecter toutes les surfaces',
    'Changer les draps et serviettes',
    'Nettoyer la salle de bain compl√®tement',
    'Nettoyer la cuisine et v√©rifier les √©quipements',
    'Passer l\'aspirateur et nettoyer les sols',
    'V√©rifier et nettoyer les fen√™tres',
    'Vider toutes les poubelles',
    'V√©rifier l\'√©tat g√©n√©ral de l\'appartement',
    'Prendre des photos apr√®s nettoyage'
  ].map(task => ({ task })),
  instructions: apartment.instructions || 'Suivre la proc√©dure standard.',
  estimatedDuration: 120
});

// Cache pour optimiser les requ√™tes r√©p√©t√©es
let staffCache = null;
let adminCache = null;
let cacheExpiry = 0;

// Trouve le staff le moins charg√© pour une date donn√©e (optimis√©)
async function getAvailableStaff(missionDate) {
  const now = Date.now();
  
  // Utilise le cache pendant 5 minutes
  if (!staffCache || now > cacheExpiry) {
    staffCache = await User.find({ role: 'Staff de m√©nage', isActive: true }).lean();
    adminCache = await User.findOne({ role: 'Admin' }).sort({ createdAt: 1 }).lean();
    cacheExpiry = now + 5 * 60 * 1000; // 5 minutes
  }
  
  if (staffCache.length === 0) throw new Error('Aucun staff disponible');
  
  // Comptage des missions par staff sur la journ√©e
  const dayStart = new Date(missionDate);
  dayStart.setHours(0,0,0,0);
  const dayEnd = new Date(dayStart);
  dayEnd.setDate(dayEnd.getDate()+1);

  // Batch query pour tous les staff members
  const staffIds = staffCache.map(u => u._id);
  const missionCounts = await Mission.aggregate([
    {
      $match: {
        assignedTo: { $in: staffIds },
        dateDebut: { $gte: dayStart, $lt: dayEnd }
      }
    },
    {
      $group: {
        _id: '$assignedTo',
        count: { $sum: 1 }
      }
    }
  ]);

  // Cr√©er un map pour les counts
  const countMap = new Map();
  missionCounts.forEach(item => {
    countMap.set(item._id.toString(), item.count);
  });

  // Trouver le staff avec le moins de missions
  let minCount = Infinity;
  let selectedStaff = staffCache[0];
  
  for (const staff of staffCache) {
    const count = countMap.get(staff._id.toString()) || 0;
    if (count < minCount) {
      minCount = count;
      selectedStaff = staff;
    }
  }
  
  return selectedStaff;
}

// Fonction utilitaire pour calculer la date de mission
function calculateMissionDate(checkoutDate) {
  const checkout = new Date(checkoutDate);
  const missionStart = new Date(checkout);
  
  if (checkout.getHours() < 12) {
    missionStart.setHours(14, 0, 0, 0);
  } else {
    missionStart.setDate(missionStart.getDate() + 1);
    missionStart.setHours(10, 0, 0, 0);
  }
  
  const missionEnd = new Date(missionStart);
  missionEnd.setHours(missionStart.getHours() + 3);
  
  return { missionStart, missionEnd };
}

// Fonction utilitaire pour obtenir les bornes du jour
function getDayBounds(date) {
  const dayStart = new Date(date);
  dayStart.setHours(0, 0, 0, 0);
  const dayEnd = new Date(dayStart);
  dayEnd.setDate(dayEnd.getDate() + 1);
  return { dayStart, dayEnd };
}

// Cr√©e une mission unique de mani√®re atomique (SOLUTION PRINCIPALE)
async function createAutomaticMission(booking, apartment) {
  console.log(`üî® Cr√©ation mission auto pour booking ${booking._id}`);

  // Calculer les dates de mission
  const { missionStart, missionEnd } = calculateMissionDate(booking.dateFin);
  const { dayStart, dayEnd } = getDayBounds(missionStart);

  // R√©cup√©rer le staff et l'admin (utilise le cache)
  const [staff, admin] = await Promise.all([
    getAvailableStaff(missionStart),
    adminCache || User.findOne({ role: 'Admin' }).sort({ createdAt: 1 }).lean()
  ]);
  
  if (!admin) throw new Error('Aucun administrateur trouv√©');

  // Assemble la mission template
  const template = getDefaultMissionTemplate(apartment, booking);
  
  // SOLUTION ATOMIQUE : Utiliser findOneAndUpdate avec upsert
  // Cela garantit qu'une seule mission auto sera cr√©√©e par jour/appartement
  const filter = {
    apartment: apartment._id,
    'metadata.autoGenerated': true,
    dateDebut: {
      $gte: dayStart,
      $lt: dayEnd
    }
  };

  const update = {
    $setOnInsert: {
      ...template,
      apartment: apartment._id,
      assignedTo: staff._id,
      createdBy: admin._id,
      dateDebut: missionStart,
      dateFin: missionEnd,
      metadata: {
        autoGenerated: true,
        bookingId: booking._id,
        bookingSource: booking.source,
        guestName: booking.guestName
      },
      createdAt: new Date(),
      updatedAt: new Date()
    }
  };

  const options = {
    upsert: true,
    new: true,
    setDefaultsOnInsert: true
  };

  try {
    const result = await Mission.findOneAndUpdate(filter, update, options);
    
    // V√©rifier si c'est une nouvelle mission (upserted) ou existante
    const isNewMission = result.createdAt.getTime() > (Date.now() - 5000); // Cr√©√©e dans les 5 derni√®res secondes
    
    if (isNewMission) {
      console.log(`‚úÖ Nouvelle mission cr√©√©e [${result._id}] pour ${apartment.name} le ${missionStart.toISOString().split('T')[0]}`);
      
      // Cr√©er la t√¢che de blanchisserie pour cette nouvelle mission
      try {
        await createLaundryTaskForMission(result, apartment, admin);
      } catch (laundryError) {
        console.error('‚ö†Ô∏è Erreur cr√©ation t√¢che blanchisserie:', laundryError);
        // Ne pas faire √©chouer la cr√©ation de mission si la t√¢che de blanchisserie √©choue
      }

      // Notifications (asynchrone pour ne pas bloquer)
      setImmediate(async () => {
        try {
          await result.populate('assignedTo', 'email firstName lastName');
          await result.populate('apartment', 'name address');
          await sendMissionNotification(result);
          console.log(`‚úâÔ∏è Notification envoy√©e √† ${staff.email}`);
        } catch (err) {
          console.error('‚ö†Ô∏è Erreur notification:', err);
        }
      });
    } else {
      console.log(`‚Ü©Ô∏è Mission auto existe d√©j√† pour ${apartment.name} le ${missionStart.toISOString().split('T')[0]} (ID: ${result._id})`);
    }

    return result;
  } catch (error) {
    // Gestion sp√©ciale des erreurs de doublon (au cas o√π l'index unique se d√©clenche)
    if (error.code === 11000 || error.name === 'MongoServerError') {
      console.log(`‚Ü©Ô∏è Doublon d√©tect√© (index unique), r√©cup√©ration de la mission existante pour ${apartment.name} le ${missionStart.toISOString().split('T')[0]}`);
      
      // R√©cup√©rer la mission existante
      const existingMission = await Mission.findOne(filter).lean();
      if (existingMission) {
        return existingMission;
      }
    }
    
    console.error(`‚ùå Erreur cr√©ation mission pour ${apartment.name}:`, error);
    throw error;
  }
}

// Fonction g√©n√©rique de traitement de bookings (optimis√©e et s√©curis√©e)
async function processBookings(filter, label) {
  console.log(`üîç Traitement des bookings (${label})‚Ä¶`);
  
  // 1. R√©cup√®re tous les bookings correspondants
  const bookings = await Booking.find(filter).lean();
  console.log(`  ‚Üí ${bookings.length} bookings r√©cup√©r√©s`);
  
  if (bookings.length === 0) return [];

  // 2. Batch query pour r√©cup√©rer les apartments
  const apartmentIds = [...new Set(bookings.map(b => b.apartment))];
  const apartments = await Apartment.find({ 
    _id: { $in: apartmentIds }, 
    isActive: true 
  }).lean();
  
  // Cr√©er un map pour les apartments
  const apartmentMap = new Map();
  apartments.forEach(apt => {
    apartmentMap.set(apt._id.toString(), apt);
  });

  // 3. Filtrer les bookings avec apartments valides
  const validBookings = bookings.filter(b => 
    apartmentMap.has(b.apartment.toString())
  );
  console.log(`  ‚Üí ${validBookings.length} bookings avec apartments actifs`);

  if (validBookings.length === 0) return [];

  // 4. Grouper les bookings par appartement et jour pour d√©tecter les doublons
  const bookingsByApartmentDay = new Map();
  
  for (const booking of validBookings) {
    const apartmentId = booking.apartment.toString();
    const { missionStart } = calculateMissionDate(booking.dateFin);
    const dayKey = missionStart.toISOString().split('T')[0]; // YYYY-MM-DD de la mission
    const key = `${apartmentId}_${dayKey}`;
    
    if (!bookingsByApartmentDay.has(key)) {
      bookingsByApartmentDay.set(key, []);
    }
    bookingsByApartmentDay.get(key).push(booking);
  }

  // 5. Pour chaque groupe (appartement + jour de mission), ne traiter qu'un seul booking
  const bookingsToProcess = [];
  for (const [key, dayBookings] of bookingsByApartmentDay) {
    if (dayBookings.length > 1) {
      console.log(`  üìÖ ${key}: ${dayBookings.length} bookings pour la m√™me date de mission, traitement du dernier checkout seulement`);
    }
    // Prendre le booking avec la date de fin la plus tardive (dernier checkout)
    const selectedBooking = dayBookings.sort((a, b) => b.dateFin.getTime() - a.dateFin.getTime())[0];
    bookingsToProcess.push(selectedBooking);
  }

  console.log(`  ‚Üí ${bookingsToProcess.length} bookings uniques √† traiter (apr√®s d√©duplication par jour de mission)`);

  if (bookingsToProcess.length === 0) return [];

  // 6. Traitement s√©quentiel pour √©viter les conflits de concurrence
  // (Plus s√ªr que le parall√©lisme pour les op√©rations atomiques)
  const results = [];
  
  for (const booking of bookingsToProcess) {
    try {
      const apartment = apartmentMap.get(booking.apartment.toString());
      const mission = await createAutomaticMission(booking, apartment);
      results.push({ 
        bookingId: booking._id, 
        missionId: mission._id, 
        success: true,
        created: mission.createdAt.getTime() > (Date.now() - 10000) // Cr√©√©e dans les 10 derni√®res secondes
      });
    } catch (err) {
      console.error(`‚úñÔ∏è Erreur booking ${booking._id}:`, err.message);
      results.push({ 
        bookingId: booking._id, 
        success: false, 
        error: err.message 
      });
    }
  }

  const successful = results.filter(r => r.success && r.created).length;
  const existing = results.filter(r => r.success && !r.created).length;
  const failed = results.filter(r => !r.success).length;
  
  console.log(`‚úÖ R√©sultats: ${successful} nouvelles missions, ${existing} existantes, ${failed} √©checs`);
  return results;
}

// R√©servations finissant dans 5 jours (optimis√©)
// R√©servations tombant entre aujourd'hui et 30 jours (overlap inclus)
async function processUpcomingBookings() {
  const now = new Date();
  const in30Days = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);

  return processBookings(
    {
      status: 'Confirm√©',
      // On prend tout booking qui a une portion dans [now, in30Days]
      dateDebut: { $lte: in30Days },
      dateFin:   { $gte: now }
    },
    '√† venir (30 jours overlap)'
  );
}


// R√©servations termin√©es il y a moins de 24h (optimis√©)
async function processRecentlyEndedBookings() {
  const now = new Date();
  const yesterday = new Date(now.getTime() - 24*60*60*1000);
  
  return processBookings(
    { 
      dateFin: { $gte: yesterday, $lte: now }, 
      status: 'Confirm√©' 
    },
    'r√©centes (<24h)'
  );
}

// Fonction pour invalider le cache (utile pour les tests)
function clearCache() {
  staffCache = null;
  adminCache = null;
  cacheExpiry = 0;
}

module.exports = {
  createAutomaticMission,
  processUpcomingBookings,
  processRecentlyEndedBookings,
  getDefaultMissionTemplate,
  clearCache
};
